"""add_company_code

Revision ID: 20b0fa130fe2
Revises: 293c5c0a563c
Create Date: 2025-12-02 19:30:25.714007

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '20b0fa130fe2'
down_revision: Union[str, None] = '293c5c0a563c'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    import random
    from sqlalchemy import inspect
    
    connection = op.get_bind()
    inspector = inspect(connection)
    existing_tables = inspector.get_table_names()
    
    # Vérifier si la table companies existe
    if 'companies' not in existing_tables:
        # La table n'existe pas encore, on ne fait rien (elle sera créée par une autre migration)
        return
    
    # Vérifier si la colonne code existe déjà
    existing_columns = [col['name'] for col in inspector.get_columns('companies')]
    if 'code' in existing_columns:
        # La colonne existe déjà, on ne fait rien
        return
    
    # Détecter le type de base de données
    dialect = connection.dialect.name
    
    if dialect == 'postgresql':
        # PostgreSQL : utiliser ALTER TABLE pour ajouter la colonne
        # D'abord, ajouter la colonne comme nullable
        op.add_column('companies', sa.Column('code', sa.String(), nullable=True))
        
        # Générer des codes uniques pour les entreprises existantes
        result = connection.execute(sa.text("SELECT id FROM companies WHERE code IS NULL"))
        companies = result.fetchall()
        
        used_codes = set()
        for (company_id,) in companies:
            # Générer un code unique à 6 chiffres
            while True:
                code = f"{random.randint(100000, 999999)}"
                if code not in used_codes:
                    used_codes.add(code)
                    connection.execute(
                        sa.text("UPDATE companies SET code = :code WHERE id = :id"),
                        {"code": code, "id": company_id}
                    )
                    break
        
        # Maintenant, rendre la colonne NOT NULL
        op.alter_column('companies', 'code', nullable=False)
        
        # Créer l'index unique
        op.create_index(op.f('ix_companies_code'), 'companies', ['code'], unique=True)
        
    else:
        # SQLite : créer une nouvelle table (méthode originale)
        # 1. Créer une table temporaire avec la colonne code
        op.create_table(
            'companies_new',
            sa.Column('id', sa.Integer(), nullable=False),
            sa.Column('code', sa.String(), nullable=False),
            sa.Column('name', sa.String(), nullable=False),
            sa.Column('sector', sa.String(), nullable=True),
            sa.Column('is_active', sa.Boolean(), nullable=False),
            sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
            sa.PrimaryKeyConstraint('id')
        )
        
        # 2. Récupérer les entreprises existantes
        result = connection.execute(sa.text("SELECT id, name, sector, is_active, created_at FROM companies"))
        companies = result.fetchall()
        
        # 3. Générer des codes uniques et insérer dans la nouvelle table
        used_codes = set()
        for company in companies:
            company_id, name, sector, is_active, created_at = company
            # Générer un code unique à 6 chiffres
            while True:
                code = f"{random.randint(100000, 999999)}"
                if code not in used_codes:
                    used_codes.add(code)
                    connection.execute(
                        sa.text("""
                            INSERT INTO companies_new (id, code, name, sector, is_active, created_at)
                            VALUES (:id, :code, :name, :sector, :is_active, :created_at)
                        """),
                        {
                            "id": company_id,
                            "code": code,
                            "name": name,
                            "sector": sector,
                            "is_active": is_active,
                            "created_at": created_at
                        }
                    )
                    break
        
        # 4. Supprimer l'ancienne table et renommer la nouvelle
        op.drop_table('companies')
        op.rename_table('companies_new', 'companies')
        
        # 5. Créer les index
        op.create_index(op.f('ix_companies_code'), 'companies', ['code'], unique=True)
        op.create_index(op.f('ix_companies_id'), 'companies', ['id'], unique=False)
        op.create_index(op.f('ix_companies_name'), 'companies', ['name'], unique=False)


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_companies_code'), table_name='companies')
    op.drop_column('companies', 'code')
    # ### end Alembic commands ###
